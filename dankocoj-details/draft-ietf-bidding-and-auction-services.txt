



Network Working Group                                           D. Kocoj
Internet-Draft                                            B. R. Hamilton
Intended status: Standards Track                                  Google
Expires: 21 March 2025                                 17 September 2024


                      Bidding and Auction Services
             draft-ietf-bidding-and-auction-services-latest

Abstract

   The Bidding and Auction Services provide a way for advertising
   auctions to execute in remote environments while preserving user
   privacy.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Source for this draft and an issue tracker can be found at
   https://github.com/privacysandbox/draft-ietf-protected-audience-
   auction-service.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 21 March 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Scope
     1.2.  Terminology
   2.  Message Format Specifications
     2.1.  Overview
       2.1.1.  Common Definitions
     2.2.  Browser to Bidding and Auction Services
       2.2.1.  Request Payload Data
       2.2.2.  Compression
       2.2.3.  Framing and Padding
       2.2.4.  Encryption
       2.2.5.  Payload Optimization
     2.3.  Bidding and Auction Services To Browser
       2.3.1.  Decryption
       2.3.2.  Decompression
       2.3.3.  Response Payload Data
   3.  Security Considerations
   4.  IANA Considerations
   5.  Normative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   Today, real-time bidding and ad auctions are executed on servers that
   may not provide technical guarantees of security.  Some users have
   concerns about how their data is handled to generate relevant ads and
   in how that data is shared.  Protected Audience API (Android
   (https://developer.android.com/design-for-safety/privacy-sandbox/
   fledge), Chrome (https://developer.chrome.com/docs/privacy-sandbox/
   fledge/)) provides ways to preserve privacy and limit third-party
   data sharing by serving personalized ads based on previous mobile app
   or web engagement.

   For all platforms, Protected Audience may require real-time services
   (https://github.com/privacysandbox/fledge-docs/blob/main/
   trusted_services_overview.md).  In the initial proposal by Chrome
   (https://github.com/WICG/turtledove/blob/main/FLEDGE.md), bidding and
   auction for Protected Audience ad demand is executed locally.  This
   can demand computation requirements that may be impractical to
   execute on devices with limited processing power, or may be too slow
   to render ads due to network latency.

   This Bidding and Auction Services proposal outlines a way to allow
   Protected Audience computation to take place on cloud servers, rather
   than running locally on a user's device.  Moving computations to the
   cloud has the following benefits:

   *  Scalable auctions.

   *  A scalable ad auction may include several buyers and sellers and
      that can demand more compute resources and network bandwidth.

   *  System health of the user's device.

   *  Ensure better system health of the user's device by freeing up
      computational cycles and network bandwidth.

   *  Better latency of ad auctions.

   *  Server to server communication on the cloud is faster than
      multiple device to server calls.

   *  Adtech code can execute faster on servers with higher computing
      power compared to a device.

   *  Servers have better processing power.

   *  Adtechs can run more compute intensive workloads on a server
      compared to a device for better utility.

   Standardized protocols for interacting with Bidding and Auction
   Services are essential to creating a diverse and healthy ecosystem
   for such services.

1.1.  Scope

   This document provides a specification for the request and response
   message format that a browser can use to communicate with remote
   services that allows the browser to offload much of the work involved
   in running an advertisement selection auction as part of the
   browser's implementation of the Protected Audience API.

   This document does not describe distribution of private keys to the
   bidding and auction services.

1.2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.  Message Format Specifications

2.1.  Overview

   To understand this document, it is important to know that the
   communication between the browser and the remote servers uses a
   request-response message exchange pattern.  The request will first
   reach a seller server, after which the seller will forward parts of
   the request to buyer servers.  It is then up to the seller server to
   gather buyer responses and form a final response for the browser.
   More detail about the seller and buyer servers can be found in the
   server-side system design documentation
   (https://github.com/privacysandbox/protected-auction-services-
   docs/blob/main/bidding_auction_services_system_design.md).

2.1.1.  Common Definitions

   Section 2 makes frequent use of the following definitions.

        +=========================================+==============+
        | Term with CDDL Definition               | Detailed     |
        |                                         | Reference    |
        +=========================================+==============+
        | json = tstr                             | [JSON]       |
        +-----------------------------------------+--------------+
        | uuid = tstr .regexp "[a-fA-F0-9]{8}-[a- | [RFC9562]    |
        | fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-       |              |
        | F0-9]{4}-[a-fA-F0-9]{12}"               |              |
        +-----------------------------------------+--------------+
        | origin = tstr .regexp                   | [ORIGIN]     |
        | "https://([^/:](:[0-9]+)?/"             |              |
        +-----------------------------------------+--------------+
        | currency = tstr .size 3 .regexp         | [ISO4217]    |
        | /^[A-Z]{3}$/                            |              |
        +-----------------------------------------+--------------+
        | adRenderUrl = tstr                      | [URL]        |
        +-----------------------------------------+--------------+
        | adRenderId = tstr                       | [ADRENDERID] |
        +-----------------------------------------+--------------+
        | interestGroupOwner = origin             | TODO         |
        +-----------------------------------------+--------------+

                                 Table 1

2.2.  Browser to Bidding and Auction Services

   This section describes how the browser MUST form and serialize
   request messages in order to communicate with the Bidding and Auction
   services.

2.2.1.  Request Payload Data

   TODO: The W3C spec produces a map from IG-owner to IGs and this
   section needs to specify how that map goes into this CDDL.

   A request payload primarily consists of interest groups.  A list of
   interest group is represented by the following [CDDL]:

   interestGroups = [ * interestGroup ]
   interestGroup = {
     ; This interest group's name, see
     ; https://wicg.github.io/turtledove/#interest-group-name.
     name: tstr,

     ; Keys used to look up real-time bidding signals, see
     ; https://wicg.github.io/turtledove/#interest-group-trusted-bidding-signals-keys.
     ? biddingSignalsKeys: [* tstr],
     ; Data about the user that the bidder can use during bid calculation, see
     ; https://wicg.github.io/turtledove/#interest-group-user-bidding-signals.
     ? userBiddingSignals: json,
     ; Contains various ads that the interest group might show. See
     ; https://wicg.github.io/turtledove/#interest-group-ads.
     ? ads: [* adRenderId],

     ; Contains various ad components (or "products") that can be used to
     ; construct ads composed of multiple pieces — a top-level ad template
     ; "container" which includes some slots that can be filled in with
     ; specific "products". See
     ; https://wicg.github.io/turtledove/#interest-group-ad-components.
     ? components: [* adRenderId],
     ? browserSignals: {
       ; Number of times the group was joined in the last 30 days.
       ? joinCount: int,

       ; Number of times the group bid in an auction in the last 30
       ; days.
       ? bidCount: int,

       ; Tuple of time-ad pairs for a previous win for this interest
       ; group that occurred in the last 30 days.
       ; The time is specified in seconds before the containing
       ; auctionBlob was requested.
       ? prevWins: [* [int, adRenderId]],

       ; The most recent join time for this group expressed
       ; in milli seconds before the containing auctionBlob
       ; was requested. This field will be used by newer client
       ; versions. For older devices, the precison will be in seconds.
       ; If recencyMs is present, this value will be used to offer
       ; higher precision. If not, recency will be used. Only
       ; one of the recency or recencyMs is expected to present in
       ; the request.
       ? recencyMs: int
     }
   }

   A list of interest groups for each owner MUST first be represented as
   [CBOR], and then the serialized list MUST be indiviudally compressed
   according to the compression algorithm specified in the message
   framing (Section 2.2.3).  This compressed interest group data MUST
   then be aggregated into a map in the complete request, which MUST be
   [CBOR] represented by the following [CDDL]:

   request = {
     version: int,
     generationId: uuid,
     publisher: origin,
     interestGroups: {
       ; Map of interest group owner to CBOR encoded list of interest
       ; groups compressed using the method described in § Compression.
       * interestGroupOwner => bstr
     },
     ? enableDebugReporting: bool
   }

   The complete request MUST also be compressed using the same
   compression algorithm as specified in the message framing
   (Section 2.2.3).

2.2.2.  Compression

   The payload MAY undergo compression.

   The compression method's value in bits 4-0 in Section 2.2.3
   corresponds to the below table:

                    +=============+==================+
                    | Compression | Description      |
                    +=============+==================+
                    |      0      | No Compression   |
                    +-------------+------------------+
                    |      1      | Brotli [RFC7932] |
                    +-------------+------------------+
                    |      2      | GZIP [RFC1952]   |
                    +-------------+------------------+
                    |     3-31    | Reserved         |
                    +-------------+------------------+

                                 Table 2

2.2.3.  Framing and Padding

   The plaintext message has the following framing:

   +==========+=========+=============+========+=============+=========+
   | Byte     | 0       | 0           | 1 to 4 | 5 to        | Size+5  |
   |          |         |             |        | Size+4      | to end  |
   +==========+=========+=============+========+=============+=========+
   | Bits     | 7-5     | 4-0         | *      | *           | *       |
   +----------+---------+-------------+--------+-------------+---------+
   | Contents | Version | Compression | Size   | Request     | Padding |
   |          |         |             |        | Payload     |         |
   +----------+---------+-------------+--------+-------------+---------+

                                  Table 3

   where the the first 3 bits of the frame header specify the payload
   version and the following 5 bits specify the compression algorithm.
   The format described in this document corresponds to version 0.

   Messages MAY be zero padded so that the encrypted request is one of
   the following bin sizes: 0KiB, 5KiB, 10KiB, 20KiB, 30KiB, 40KiB,
   55KiB.  An implementation MAY need to remove some data from the
   payload to fit inside the largest bucket.

   A compatible implementation processing requests SHOULD NOT rely on a
   specific padding scheme for requests.

2.2.4.  Encryption

   After framing and padding the compressed payload, the entire
   plaintext message is encrypted using [HPKE] with the encapsulation
   performed similarly to Section 4.3 (https://www.rfc-editor.org/rfc/
   rfc9458#section-4.3) of [OHTTP].  Details on how to acquire [HPKE]
   keys are out of scope for this document, however we assume they will
   be provided by the browser as a Key Configuration (https://www.rfc-
   editor.org/rfc/rfc9458#name-key-configuration) and are required
   inputs to the {#encapsulation} process.

2.2.4.1.  HPKE Context

   Section 5.1 (https://www.rfc-editor.org/rfc/rfc9180.html#name-
   creating-the-encryption-con) of [HPKE] describes how to create the
   Context required for encryption.  This is considered the 'sending'
   HPKE context, and browser must store it for later use when decrypting
   the response, as described in Section 2.3.1.

   The HPKE context struct is defined by the following [CDDL]:

   hpke_context = {
      TODO
   }

2.2.4.2.  Encapsulation

   Instead of encapsulating Binary HTTP [BINARY] as per Step 1 in OHTTP
   (https://www.rfc-editor.org/rfc/rfc9458#section-4.3-4.1.1), the
   output from Section 2.2.3 MUST be used as-is.  This means that we are
   repurposing the [OHTTP] encapsulation mechanism, so we are required
   to define new media types (https://www.rfc-editor.org/rfc/
   rfc9458.html#name-repurposing-the-encapsulati):

   *  The OHTTP request media type is “message/auction request”

   *  The OHTTP response media type is “message/auction response”

   Note that these media types are concatenated with other fields when
   creating the HPKE encryption context (https://www.rfc-editor.org/rfc/
   rfc9458.html#name-encapsulation-of-requests), and are not HTTP
   content or media types.  In order to perform the encapsulation, the
   steps in the OHTTP encapsulation process (https://www.rfc-
   editor.org/rfc/rfc9458#section-4.3-3) MUST be followed precisely,
   except with an info equivalent to message/auction request.

2.2.5.  Payload Optimization

   A compatible implementation MAY support control over how interest
   groups are serialized into a request and the size of the request.  An
   example implementation for this feature is as follows:

   This algorithm takes as input all of the relevant interest groups, an
   optional desired total size, and an optional list of interest group
   owners to include each with an optional desired size.

   1.   If desired total size is not specified, but the list of interest
        group owners includes at least one entry with a specified
        desired size:

        1.  Set desired total size to the sum of all specified desired
            size in the list of interest group owners.

   2.   Group the list of relevant interest groups by owner into a map
        of from interest group owner to a list of interest groups sorted
        by decreasing priority, interest group map.

   3.   If the list of interest group owners is specified, remove
        interest groups whose owner is not on the list.

   4.   Construct a request, request, as normal only with the value of
        the interestGroups field for each interest group owner as zero
        length.

   5.   Set current_size to be the serialized size of the encrypted
        request created from request without padding.

   6.   Set remaining_allocated_size to 0.

   7.   Set remaining_unsized_owners to 0.

   8.   For each interest group owner, interest group list in interest
        group map:

        1.  If there is a desired size for interest group owner:

            1.  Increment remaining_allocated_size by desired size.

        2.  Otherwise

            1.  Increment remaining_unsized_owners by 1.

   9.   For each interest group owner, interest group list in interest
        group map where there is a desired size specified for interest
        group owner:

        1.  If the number of unsized_owners is not 0:

            1.  Set the allowed_interest_group_size to the desired size
                for this interest group owner.  This is a fixed size
                allocation.

        2.  Otherwise:

            1.  Let remaining_size be equal to the desired total size-
                current_size.

            2.  Set the allowed_interest_group_size to
                remaining_size*desired_size/remaining_allocated_size.
                This is a proportional allocation.

        3.  Set remaining_allocated_size = remaining_allocated_size-
            current_size.

        4.  Serialize the interest group list into serialized_group.

        5.  If adding the serialized_group to request would make it more
            than allowed_interest_group_size larger than the current
            size, then remove the lowest priority interest group and
            repeat from the previous step.

        6.  Set request["interestGroups"][interest group owner] to
            serialized_group.

        7.  Set current_size to be the serialized size of the encrypted
            request created from request without padding.

   10.  For each interest group owner, interest group list in interest
        group map where there is not desired size specified for interest
        group owner:

        1.  Let remaining_size be equal to the desired total size-
            current_size.

        2.  Set the allowed_interest_group_size to
            remaining_size*/remaining_unsized_owners.  This is a equal
            size allocation.

        3.  Decrement remaining_unsized_owners by 1.

        4.  Serialize the interest group list into serialized_group.

        5.  If adding the serialized_group to request would make it more
            than allowed_interest_group_size larger than the current
            size, then remove the lowest priority interest group and
            repeat from the previous step.

        6.  Set request["interestGroups"][interest group owner] to
            serialized_group.

        7.  Set current_size to be the serialized size of the encrypted
            request created from request without padding.

   11.  If there are no interest groups in the request, discard the
        request and return an empty byte array.

   12.  Frame request as in Section 2.2.3 and zero pad up to desired
        total size.

   13.  Return the encrypted result (as in Section 2.2.4).

2.3.  Bidding and Auction Services To Browser

   This section describes how the browser MUST deserialize response
   messages from the Bidding and Auction Services.  The steps MUST be
   performed in the following order: decryption (Section 2.3.1),
   decompression (Section 2.3.2), and finally parsing the response
   payload as in Section 2.3.3.

   TODO investigate headers & context, explicitly define the inputs

2.3.1.  Decryption

   The response message is encrypted using HPKE with the encapsulation
   performed according to Section 4.4 (https://www.rfc-editor.org/rfc/
   rfc9458.html#name-encapsulation-of-responses) of [OHTTP] as the
   response to the request message.

   The browser MUST decrypt the response by following the standard
   [OHTTP] Encapsulated Response decryption procedure (https://www.rfc-
   editor.org/rfc/rfc9458#section-4.4-5).  The HPKE context used for
   decryption should be precisely the same context that was created in
   Section 2.2.4.1.

2.3.2.  Decompression

   The message framing is exactly as in Section 2.2.3, but the entire
   response payload is compressed.  Starting with Byte 0, read bits 4-0
   and use the chart in Section 2.2.2 to decode which decompression
   algorithm MUST be applied to the response payload.

   The output of the decompression process will be a payload equivalent
   to the auction server response struct (https://wicg.github.io/
   turtledove/#server-auction-response), as further described in
   Section 2.3.3.

2.3.3.  Response Payload Data

   The response has the following data, serialized as [CBOR] and
   matching the following shape (described via [CDDL]):

   response = {
     ; The ad to render.
     adRenderURL: adRenderUrl,

     ; List of URLs for component ads displayed as part of this
     ; ad.
     ? components: [* adRenderUrl],

     ; Name of the interest group to which the ad belongs.
     ; See https://wicg.github.io/turtledove/#interest-group-name.
     ? interestGroupName: tstr,

     ; Origin of the Buyer who owns the interest group.
     ; The original request for this response MUST contain this
     ; interestGroupOwner, which additionally MUST provide an interest
     ; group with interestGroupName.
     ? interestGroupOwner: interestGroupOwner,

     ; Indices of interest groups in the original request for this owner
     ; that submitted a bid.
     ? biddingGroups: {
       * interestGroupOwner => [* int]
     },

     ; Specifies which interest groups are eligible for an update on the
     ; client.
     ? updateGroups: {
       * interestGroupOwner => [* {
         ; Index of interest group in the original request for interestGroupOwner.
         index: int
         ; Browser should update the interest group represented by 'index'
         ; if its on-device last updated time is gerather than this.
         updateIfOlderThanMs: int
       }]
     },

     ; Score of the ad determined during the auction.
     ; Any value that is zero or negative indicates that the ad cannot
     ; win the auction.
     ; The winner of the auction would be the ad that was given the
     ; highest score.
     ? score: float,

     ; Bid price corresponding to an ad
     ? bid: float,

     ; Optional currency of the bid.
     ? bidCurrency: currency,

     ; Optional BuyerReportingId of the winning Ad
     ? buyerReportingId: tstr,

     ; Optional BuyerAndSellerReportingId of the winning Ad
     ? buyerAndSellerReportingId: tstr,

     ; The auction result may be ignored if set to true.
     ? isChaff: bool,

     ? winReportingUrls: {
       ? buyerReportingUrls: reportingUrls,
       ? componentSellerReportingUrls: reportingUrls,
       ? topLevelSellerReportingUrls: reportingUrls
     },

     ? error: {
       code: int,
       message: tstr
     },

     ; Arbitrary metadata to pass to the top-level seller
     ? adMetadata: json,

     ; Optional name/domain for the top-level seller in case this is a
     ; component auction.
     ? topLevelSeller: origin,

   }

   ; Defines the structure for reporting URLs.
   reportingUrls = {
     ? reportingUrl: tstr,
     ? interactionReportingUrls: { * tstr => tstr }
   }

3.  Security Considerations

   TODO

4.  IANA Considerations

   This document introduces no additional considerations for IANA.

5.  Normative References

   [ADRENDERID]
              "Protected Audience", 2024, <https://wicg.github.io/
              turtledove/#server-auction-previous-win-ad-render-id>.

   [BINARY]   Thomson, M. and C. A. Wood, "Binary Representation of HTTP
              Messages", RFC 9292, DOI 10.17487/RFC9292, August 2022,
              <https://www.rfc-editor.org/rfc/rfc9292>.

   [CBOR]     Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", STD 94, RFC 8949,
              DOI 10.17487/RFC8949, December 2020,
              <https://www.rfc-editor.org/rfc/rfc8949>.

   [CDDL]     Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/rfc/rfc8610>.

   [HPKE]     Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, "Hybrid
              Public Key Encryption", RFC 9180, DOI 10.17487/RFC9180,
              February 2022, <https://www.rfc-editor.org/rfc/rfc9180>.

   [ISO4217]  "ISO 4217 Currency codes", 2024,
              <https://www.iso.org/iso-4217-currency-codes.html>.

   [JSON]     Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/rfc/rfc8259>.

   [OHTTP]    Thomson, M. and C. A. Wood, "Oblivious HTTP", RFC 9458,
              DOI 10.17487/RFC9458, January 2024,
              <https://www.rfc-editor.org/rfc/rfc9458>.

   [ORIGIN]   "HTML Living Standard", 2024,
              <https://html.spec.whatwg.org/multipage/
              webappapis.html#concept-settings-object-origin>.

   [RFC1952]  Deutsch, P., "GZIP file format specification version 4.3",
              RFC 1952, DOI 10.17487/RFC1952, May 1996,
              <https://www.rfc-editor.org/rfc/rfc1952>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC7932]  Alakuijala, J. and Z. Szabadka, "Brotli Compressed Data
              Format", RFC 7932, DOI 10.17487/RFC7932, July 2016,
              <https://www.rfc-editor.org/rfc/rfc7932>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9562]  Davis, K., Peabody, B., and P. Leach, "Universally Unique
              IDentifiers (UUIDs)", RFC 9562, DOI 10.17487/RFC9562, May
              2024, <https://www.rfc-editor.org/rfc/rfc9562>.

   [SHA-256]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/rfc/rfc6234>.

   [URL]      "URL Living Standard", 2024,
              <https://url.spec.whatwg.org/#concept-url>.

Acknowledgments

   TODO

Authors' Addresses

   Daniel Kocoj
   Google
   Email: dankocoj@google.com


   Benjamin "Russ" Hamilton
   Google
   Email: behamilton@google.com
